import XCTest
import BigInt
@testable import ShieldedPoolCore

/// Cross-validation tests: Swift SDK crypto must produce identical results to the TypeScript SDK.
/// All expected values were generated by the TS SDK (sdk/dist/poseidon/solanaPoseidon.js).
final class CrossValidationTests: XCTestCase {

    // MARK: - Poseidon 4-Input (Width 5) Tests

    func testPoseidon4Inputs() throws {
        // Poseidon(42, 100, 1, 0) — same as nullifier computation pattern
        // Inputs as 32-byte big-endian field elements
        var commitment = Data(repeating: 0, count: 32); commitment[31] = 42
        var nullifierKey = Data(repeating: 0, count: 32); nullifierKey[31] = 100
        // epoch = 1, little-endian encoding in TS SDK, but Poseidon sees it as a field element
        // In TS: epochBuf[0] = 1 → this is LE, but as a 32-byte BE field it's a huge number
        // Actually the TS SDK writes epoch as LE: Buffer[0]=1 means the raw bytes are [1,0,0,...,0]
        var epochBytes = Data(repeating: 0, count: 32); epochBytes[0] = 1
        let leafIndexBytes = Data(repeating: 0, count: 32)

        let result = try Poseidon.hash([commitment, nullifierKey, epochBytes, leafIndexBytes])
        let expected = "1f46a3c5aa46eb0874d131bd107b2cc94660f8598d29f6fcab49857cbc1d15a4"
        XCTAssertEqual(result.hexString, expected, "Poseidon 4-input hash must match TS SDK")
    }

    // MARK: - Commitment Tests

    func testCommitmentSimple() throws {
        // commitment = Poseidon(value=1000000, owner=1, randomness=2)
        // value encoded as 32-byte big-endian
        var valueBuf = Data(repeating: 0, count: 32)
        let valueBytes = withUnsafeBytes(of: UInt64(1000000).bigEndian) { Data($0) }
        valueBuf.replaceSubrange(24..<32, with: valueBytes)

        var ownerBuf = Data(repeating: 0, count: 32); ownerBuf[31] = 1
        var randomnessBuf = Data(repeating: 0, count: 32); randomnessBuf[31] = 2

        let result = try Poseidon.hash([valueBuf, ownerBuf, randomnessBuf])
        let expected = "02c232fd3081ca0b475765d0801133b603933ca9c86cd46d0790de81e7dced0d"
        XCTAssertEqual(result.hexString, expected, "Commitment must match TS SDK")
    }

    // MARK: - Merkle Zero Hashes

    func testMerkleZeroHashes() throws {
        // Zero hash chain: z[0] = 0, z[i] = Poseidon(z[i-1], z[i-1])
        let expectedHashes = [
            "0000000000000000000000000000000000000000000000000000000000000000",
            "2098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864",
            "1069673dcdb12263df301a6ff584a7ec261a44cb9dc68df067a4774460b1f1e1",
            "18f43331537ee2af2e3d758d50f72106467c6eea50371dd528d57eb2b856d238",
            "07f9d837cb17b0d36320ffe93ba52345f1b728571a568265caac97559dbc952a",
            "2b94cf5e8746b3f5c9631f4c5df32907a699c58c94b2ad4d7b5cec1639183f55",
            "2dee93c5a666459646ea7d22cca9e1bcfed71e6951b953611d11dda32ea09d78",
            "078295e5a22b84e982cf601eb639597b8b0515a88cb5ac7fa8a4aabe3c87349d",
            "2fa5e5f18f6027a6501bec864564472a616b2e274a41211a444cbe3a99f3cc61",
            "0e884376d0d8fd21ecb780389e941f66e45e7acce3e228ab3e2156a614fcd747",
            "1b7201da72494f1e28717ad1a52eb469f95892f957713533de6175e5da190af2",
            "1f8d8822725e36385200c0b201249819a6e6e1e4650808b5bebc6bface7d7636",
            "2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a",
        ]

        var prev = Data(repeating: 0, count: 32)
        XCTAssertEqual(prev.hexString, expectedHashes[0])

        for i in 0..<12 {
            prev = try Poseidon.hash2(prev, prev)
            XCTAssertEqual(prev.hexString, expectedHashes[i + 1],
                           "Zero hash at level \(i + 1) must match TS SDK")
        }
    }

    // MARK: - Merkle Tree: Single Leaf Root

    func testSingleLeafMerkleRoot() throws {
        // Insert commitment at leaf index 0, compute root with depth 12
        var valueBuf = Data(repeating: 0, count: 32)
        let valueBytes = withUnsafeBytes(of: UInt64(1000000).bigEndian) { Data($0) }
        valueBuf.replaceSubrange(24..<32, with: valueBytes)
        var ownerBuf = Data(repeating: 0, count: 32); ownerBuf[31] = 1
        var randomnessBuf = Data(repeating: 0, count: 32); randomnessBuf[31] = 2

        let commitment = try Poseidon.hash([valueBuf, ownerBuf, randomnessBuf])
        XCTAssertEqual(commitment.hexString,
                       "02c232fd3081ca0b475765d0801133b603933ca9c86cd46d0790de81e7dced0d")

        let tree = EpochMerkleTree(epoch: 0)
        let (leafIndex, root) = try tree.insert(commitment)
        XCTAssertEqual(leafIndex, 0)

        let expected = "2c3f2c698cf32cb8b32a05f462fe125e46a34e05e85e175435531c950367a260"
        XCTAssertEqual(root.hexString, expected, "Single-leaf Merkle root must match TS SDK")
    }

    // MARK: - Merkle Tree: Two Leaves

    func testTwoLeafMerkleRoot() throws {
        var leaf0 = Data(repeating: 0, count: 32); leaf0[31] = 10
        var leaf1 = Data(repeating: 0, count: 32); leaf1[31] = 20

        // Verify parent hash
        let parentHash = try Poseidon.hash2(leaf0, leaf1)
        XCTAssertEqual(parentHash.hexString,
                       "28f221565db1a6b6ae4ebc44d155767bd3ee30793fee3523df4644fe6f1139ef",
                       "Parent hash of two leaves must match TS SDK")

        let tree = EpochMerkleTree(epoch: 0)
        let _ = try tree.insert(leaf0)
        let (_, root) = try tree.insert(leaf1)

        let expected = "10a048a06339a685033d9d28eecc4c8316b799638d689de9cd12be2b6b815798"
        XCTAssertEqual(root.hexString, expected, "Two-leaf Merkle root must match TS SDK")
    }

    // MARK: - Merkle Proof Verification

    func testMerkleProofVerification() throws {
        let tree = EpochMerkleTree(epoch: 0)

        // Insert 3 leaves
        var leaf0 = Data(repeating: 0, count: 32); leaf0[31] = 10
        var leaf1 = Data(repeating: 0, count: 32); leaf1[31] = 20
        var leaf2 = Data(repeating: 0, count: 32); leaf2[31] = 30

        let _ = try tree.insert(leaf0)
        let _ = try tree.insert(leaf1)
        let _ = try tree.insert(leaf2)

        // Get proof for each leaf and verify
        for i in 0..<3 {
            let proof = try tree.getProof(leafIndex: i)
            XCTAssertTrue(EpochMerkleTree.verifyProof(proof),
                          "Proof for leaf \(i) should verify")
        }
    }

    // MARK: - Circuit-Compatible Nullifier

    func testCircuitNullifier() throws {
        // commitment = Poseidon(value=1000000, owner=54321, randomness=67890) — big-endian
        var cValueBuf = Data(repeating: 0, count: 32)
        let vBytes = withUnsafeBytes(of: UInt64(1000000).bigEndian) { Data($0) }
        cValueBuf.replaceSubrange(24..<32, with: vBytes)

        var cOwnerBuf = Data(repeating: 0, count: 32)
        let oBytes = withUnsafeBytes(of: UInt64(54321).bigEndian) { Data($0) }
        cOwnerBuf.replaceSubrange(24..<32, with: oBytes)

        var cRandBuf = Data(repeating: 0, count: 32)
        let rBytes = withUnsafeBytes(of: UInt64(67890).bigEndian) { Data($0) }
        cRandBuf.replaceSubrange(24..<32, with: rBytes)

        let commitment = try Poseidon.hash([cValueBuf, cOwnerBuf, cRandBuf])
        XCTAssertEqual(commitment.hexString,
                       "1c3dbfcfc56388dda6d0d4bdd316171ce1c8862d57a7a5e6a819d9c03894d5b0",
                       "Circuit commitment must match TS SDK")

        // nullifier = Poseidon(commitment, nullifierKey=11111, epoch=1 LE, leafIndex=0)
        var cNullifierKey = Data(repeating: 0, count: 32)
        let nkBytes = withUnsafeBytes(of: UInt64(11111).bigEndian) { Data($0) }
        cNullifierKey.replaceSubrange(24..<32, with: nkBytes)

        var cEpochBuf = Data(repeating: 0, count: 32)
        cEpochBuf[0] = 1 // little-endian encoding matching TS SDK

        let cLeafIdxBuf = Data(repeating: 0, count: 32) // 0

        let nullifier = try Poseidon.hash([commitment, cNullifierKey, cEpochBuf, cLeafIdxBuf])
        XCTAssertEqual(nullifier.hexString,
                       "2ea6bb414f1cd89d97d774d5823fc5dff4fbaee5a9a77d0930903e0c3400160f",
                       "Circuit nullifier must match TS SDK")
    }

    // MARK: - Merkle Tree Edge Cases

    func testEmptyTreeRoot() throws {
        let tree = EpochMerkleTree(epoch: 0)
        let root = tree.getRoot()
        let expected = "2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a"
        XCTAssertEqual(root.hexString, expected,
                       "Empty tree root must match depth-12 zero hash")
    }

    func testTreeStateTransitions() throws {
        let tree = EpochMerkleTree(epoch: 1)
        XCTAssertEqual(tree.getState(), .active)

        let leaf = Data(repeating: 1, count: 32)
        let _ = try tree.insert(leaf)
        XCTAssertEqual(tree.leafCount, 1)

        // Finalize
        let root = tree.getRoot()
        tree.setFinalRoot(root)
        XCTAssertEqual(tree.getState(), .finalized)

        // Can't insert into finalized tree
        XCTAssertThrowsError(try tree.insert(leaf))
    }

    func testProofForNonExistentLeaf() throws {
        let tree = EpochMerkleTree(epoch: 0)
        XCTAssertThrowsError(try tree.getProof(leafIndex: 0))
    }

    // MARK: - Poseidon Edge Cases

    func testPoseidonSingleInput() throws {
        // Poseidon(0) — single zero input
        let zero = Data(repeating: 0, count: 32)
        let result = try Poseidon.hash([zero])
        // Should produce a non-zero output
        XCTAssertNotEqual(result, zero, "Poseidon(0) should not be zero")
        XCTAssertEqual(result.count, 32, "Output should be 32 bytes")
    }

    func testPoseidonDeterministic() throws {
        let input1 = Data(repeating: 42, count: 32)
        let input2 = Data(repeating: 99, count: 32)

        let result1 = try Poseidon.hash([input1, input2])
        let result2 = try Poseidon.hash([input1, input2])
        XCTAssertEqual(result1, result2, "Poseidon must be deterministic")

        // Different inputs must produce different outputs
        let result3 = try Poseidon.hash([input2, input1])
        XCTAssertNotEqual(result1, result3, "Swapped inputs must produce different hash")
    }

    func testPoseidonFieldOverflow() throws {
        // Input larger than BN254 prime should be reduced mod p
        var maxInput = Data(repeating: 0xFF, count: 32)
        let result = try Poseidon.hash([maxInput])
        XCTAssertEqual(result.count, 32)
        // Verify result is in field
        let resultInt = BigUInt(result)
        XCTAssertTrue(resultInt < Poseidon.BN254_PRIME, "Result must be in field")
    }

    // MARK: - Root History

    func testRootHistory() throws {
        let tree = EpochMerkleTree(epoch: 0)

        var leaf0 = Data(repeating: 0, count: 32); leaf0[31] = 1
        var leaf1 = Data(repeating: 0, count: 32); leaf1[31] = 2

        let (_, root0) = try tree.insert(leaf0)
        let (_, root1) = try tree.insert(leaf1)

        XCTAssertTrue(tree.isKnownRoot(root0), "Historical root should be known")
        XCTAssertTrue(tree.isKnownRoot(root1), "Current root should be known")

        let fakeRoot = Data(repeating: 0xFF, count: 32)
        XCTAssertFalse(tree.isKnownRoot(fakeRoot), "Unknown root should not be known")
    }
}

// MARK: - Helpers

extension Data {
    /// Hex string representation (lowercase, no prefix)
    var hexString: String {
        map { String(format: "%02x", $0) }.joined()
    }

    /// Initialize from hex string
    init?(hexString: String) {
        let hex = hexString.hasPrefix("0x") ? String(hexString.dropFirst(2)) : hexString
        guard hex.count % 2 == 0 else { return nil }
        var data = Data(capacity: hex.count / 2)
        var index = hex.startIndex
        while index < hex.endIndex {
            let nextIndex = hex.index(index, offsetBy: 2)
            guard let byte = UInt8(hex[index..<nextIndex], radix: 16) else { return nil }
            data.append(byte)
            index = nextIndex
        }
        self = data
    }
}
